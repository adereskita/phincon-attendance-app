//
//  DashboardViewController.swift
//  phincon-attendance-app
//
//  Created by Ade on 3/24/22.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SwiftKeychainWrapper

protocol DashboardDisplayLogic: AnyObject {
    func presenter(didLoadCheckOutLoc response: DashboardModels.GetLocation.Response)
    func presenter(didLoadCheckInLoc response: DashboardModels.GetLocation.Response)
    func presenter(didCheckIn response: DashboardModels.CheckLocation.Response)
    func presenter(didCheckOut response: DashboardModels.CheckLocation.Response)
    func presenter(ButtonStatus response: DashboardModels.ViewModel)
    func presenter(didFailedCheck status: Int, message: String)
    func presenter(expiredLoginSession status: Int, message: String)
}

class DashboardViewController: UIViewController, DashboardDisplayLogic {
    
    var interactor: DashboardBusinessLogic?
    var router: (NSObjectProtocol & DashboardRoutingLogic & DashboardDataPassing)?

  // MARK: Object lifecycle
  
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
  
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
  
  // MARK: Setup
  
    private func setup() {
        let viewController = self
        let interactor = DashboardInteractor()
        let presenter = DashboardPresenter()
        let router = DashboardRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
  
  // MARK: Routing
  
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
  
  // MARK: View lifecycle
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.navigationController!.setNavigationBarHidden(true, animated: false)
        isCheckOut = userDefault.bool(forKey: "isCheckOut")
        self.locationID = ""
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        let request = DashboardModels.IsLogin.Request()
        interactor?.checkLoginSession(request: request)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        setDataList()
        let request = HistoryModels.FetchHistory.Request(log: "day")
        interactor?.checkButtonStatus(request: request) // for status button
//        let request = DashboardModels.IsLogin.Request()
//        interactor?.checkLoginSession(request: request)
    }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
          return .lightContent
    }
    
    override func loadView() {
        super.loadView()
        setupViewNib()
    }

    var timer = Timer()
    
    let userDefault = UserDefaults.standard
    let keyChainWrapper = KeychainWrapper.standard
    
    weak var dashboardView: DashboardView!
    
    var locationID  = ""
    var isCheckOut: Bool! {
        didSet {
            self.dashboardView.dashboardTableView.reloadData()
        }
    }
    
    var checkInLists: [Location] = [Location]() {
        // to get data on start
        didSet {
//            DispatchQueue.main.async {
            self.dashboardView.dashboardTableView.reloadData()
//            }
        }
    }
    
    var checkOutLists: [Location] = [Location]() {
        // to get data on start
        didSet {
            self.dashboardView.dashboardTableView.reloadData()
        }
    }
    
    private func setDataList() {
        let request = DashboardModels.GetLocation.Request()
        interactor?.loadCheckInList(request: request)
        interactor?.loadCheckOutList(request: request)
    }
    
    private func setupViewNib() {
        let screenRect = UIScreen.main.bounds
        let screenWidth = screenRect.size.width
        let screenHeight = screenRect.size.height
        
        let dashboardViews = DashboardView(frame: CGRect(x: 0, y: 0, width: screenWidth, height: screenHeight))
        self.view = dashboardViews
//        self.view.addview(dashboardViews)
        
        self.dashboardView = dashboardViews
        self.dashboardView.navBar.delegate = self
    }
    
    private func setupUI() {
        dashboardView.dashboardTableView.delegate = self
        dashboardView.dashboardTableView.dataSource = self
        
        dashboardView.dashboardTableView.refreshControl = UIRefreshControl()
        dashboardView.dashboardTableView.refreshControl?.addTarget(self, action: #selector(didPullToRefresh), for: .valueChanged)
        dashboardView.dashboardTableView.refreshControl?.backgroundColor = colorUtils.darkBlueHead
        dashboardView.dashboardTableView.refreshControl?.tintColor = .white
        
        self.view.backgroundColor = colorUtils.darkBlueHead
    }
    
    func spinnerSetup(isSucces: Bool, message: String?) {
        self.view.isUserInteractionEnabled = false
        dashboardView.spinner.isHidden = false
        dashboardView.spinner.style = .medium
        dashboardView.spinner.backgroundColor = UIColor(white: 0.9, alpha: 0.6)
        dashboardView.spinner.layer.cornerRadius = 10.0
        dashboardView.spinner.translatesAutoresizingMaskIntoConstraints = false
        dashboardView.spinner.startAnimating()

        // wait two seconds to simulate some work happening
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.dashboardView.spinner.isHidden = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.view.isUserInteractionEnabled = true
                self.alertSetup(isSuccess: isSucces, error: message)
            }
        }
    }
    
    func alertSetup(isSuccess: Bool, error message: String?) {
        if isSuccess {
            let alert = UIAlertController(title: "Success", message: message, preferredStyle: UIAlertController.Style.alert)
            alert.addAction(UIAlertAction(title: "OK", style: UIAlertAction.Style.default, handler: nil))
            self.present(alert, animated: true, completion: nil)
        } else {
            let alert = UIAlertController(title: "Error Occurred", message: message, preferredStyle: UIAlertController.Style.alert)
            alert.addAction(UIAlertAction(title: "OK", style: UIAlertAction.Style.default, handler: nil))
            self.present(alert, animated: true, completion: nil)
        }
    }
    
    // MARK: Update from Presenter
    func presenter(ButtonStatus response: DashboardModels.ViewModel) {
        let activity = response.activity
        
        if activity == "out" || activity == nil {
            userDefault.set(false, forKey: "isCheckOut")
            isCheckOut = false
        } else {
            userDefault.set(true, forKey: "isCheckOut")
            isCheckOut = true
        }
    }
    
    func presenter(didCheckOut response: DashboardModels.CheckLocation.Response) {
        let msg = "Check-Out was successful"
        spinnerSetup(isSucces: true, message: msg)
    }
    
    func presenter(didCheckIn response: DashboardModels.CheckLocation.Response) {
        let msg = "Check-in was successful"
        spinnerSetup(isSucces: true, message: msg)
    }
    
    func presenter(didLoadCheckInLoc response: DashboardModels.GetLocation.Response) {
        checkInLists.append(contentsOf: response.success.result!)
    }
    
    func presenter(didLoadCheckOutLoc response: DashboardModels.GetLocation.Response) {
        checkOutLists.append(contentsOf: response.success.result!)
    }
    
    func presenter(didFailedCheck status: Int, message: String) {
        let alert = UIAlertController(title: "Network Problem", message: "No Connection", preferredStyle: UIAlertController.Style.alert)
        alert.addAction(UIAlertAction(title: "OK", style: UIAlertAction.Style.default, handler: nil))

        if isCheckOut {
            userDefault.set(false, forKey: "isCheckOut")
            isCheckOut = userDefault.bool(forKey: "isCheckOut")
            if !Connectivity.isConnectedToInternet {
                self.present(alert, animated: true, completion: nil)
            } else {
                spinnerSetup(isSucces: false, message: "There is problem with your Location.")
            }
        } else {
            userDefault.set(true, forKey: "isCheckOut")
            isCheckOut = userDefault.bool(forKey: "isCheckOut")
            if !Connectivity.isConnectedToInternet {
                self.present(alert, animated: true, completion: nil)
            } else {
                spinnerSetup(isSucces: false, message: "There is problem with your Location.")
            }
        }
    }
    
    func presenter(expiredLoginSession status: Int, message: String) {
        if status == 403 || status == 401 {
            keyChainWrapper.removeObject(forKey: "user_token")
//            userDefault.set(nil, forKey: "user_token")
            router?.routeToLogoutUser(segue: nil)
        } else {
            if !Connectivity.isConnectedToInternet {
                let alert = UIAlertController(title: "Network Problem", message: "No Connection", preferredStyle: UIAlertController.Style.alert)
                alert.addAction(UIAlertAction(title: "Ok", style: UIAlertAction.Style.default, handler: nil))
                self.present(alert, animated: true, completion: nil)
            }
        }
    }
    
    @objc func didPullToRefresh() {
        let request = DashboardModels.GetLocation.Request()
        DispatchQueue.main.asyncAfter(deadline: .now()+2) {
            if self.isCheckOut {
                self.checkOutLists.removeAll()
                self.interactor?.loadCheckOutList(request: request)
            } else {
                self.checkInLists.removeAll()
                self.interactor?.loadCheckInList(request: request)
            }
//            self.dashboardTableView.reloadData()
            self.dashboardView.dashboardTableView.refreshControl?.endRefreshing()
        }
    }
}

// MARK: TableView
extension DashboardViewController: UITableViewDelegate, UITableViewDataSource {
    
    enum SectionType: Int {
        case checkBox
        case location
        
        init(section: Int) {
            switch section {
            case 0:
                self = .checkBox
            default:
                self = .location
            }
        }
    }
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 2
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        let section = SectionType.init(section: section)
        
        switch section {
        case .checkBox:
            return 1
        case .location:
            if isCheckOut {
                return checkOutLists.count
            } else {
                return checkInLists.count
            }
        }
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let section = SectionType.init(section: indexPath.section)
        
        switch section {
        case .checkBox:
            let cell = tableView.dequeueReusableCell(withIdentifier: DashboardHeaderCell.identifier, for: indexPath) as! DashboardHeaderCell
            
            cell.delegate = self
                        
            let date = Date()
            let df = DateFormatter()
            df.dateFormat = "dd MMM yyyy"
            let dates = df.string(from: date)
            
            cell.dateLabel.text = dates
            cell.isCheckOut = self.isCheckOut
            
            return cell
            
        case .location:
            let cell = tableView.dequeueReusableCell(withIdentifier: "DashboardTableCell", for: indexPath) as! DashboardTableCell
            if isCheckOut {
                let listObj = checkOutLists[indexPath.row]
                cell.setDashboardCellView(listObj)
                cell.selectedColor = colorUtils.yellowCheckout
                cell.selectedColorLbl = .black
                
                return cell
                
            } else {
                let listObj = checkInLists[indexPath.row]
                cell.setDashboardCellView(listObj)
                cell.selectedColor = colorUtils.blueCheckout
                cell.selectedColorLbl = .white
                
                return cell
            }
        }
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let headerSection = CustomSectionView()
        return headerSection
    }
    
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        let section = SectionType.init(section: section)

        switch section {
        case .checkBox:
            return 0
        case .location:
            return 44
        }
    }
    
    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
        let section = SectionType.init(section: section)

        switch section {
        case .checkBox:
            return nil
        case .location:
            return "Location"
        }
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if indexPath.section > 0 {
            let listObj = checkInLists[indexPath.row]
            self.locationID = listObj.id!
        }
    }
        
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if indexPath.section > 0 {
            return tableView.estimatedRowHeight
        }
        return 300
//        let heightRatio = UIScreen.main.bounds.height / 736
//        let tableViewHeight = tableView.frame.size.height
//        return tableView.estimatedRowHeight * heightRatio
    }
    
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        let y = scrollView.contentOffset.y
        
        let swipingDown = y <= 0
        let shouldSnap = y > 30
        let labelHeight = dashboardView.navBar.titleLabel.frame.height + 16
                
        UIView.animate(withDuration: 0.3) { [self] in
//            dashboardView.navBar.titleLabel.alpha = swipingDown ? 1.0 : 0.0
        }
        
        UIViewPropertyAnimator.runningPropertyAnimator(withDuration: 0.3, delay: 0, animations: {
            let labels = self.dashboardView.navBar.titleLabel.font!
//            self.dashboardView.navBarViewTopConstraint.constant = shouldSnap ? -labelHeight : 16
            self.dashboardView.navBar.titleLabel.font = shouldSnap ? labels.withSize(16) : labels.withSize(21)
            self.dashboardView.navbarView.backgroundColor = colorUtils.darkBlueHead
//            self.dashboardView.navBar.rightButton.frame.size = shouldSnap ? CGSize(width: 16, height: 16) : CGSize(width: 21, height: 21)
//            self.dashboardView.navBar.rightButton.translatesAutoresizingMaskIntoConstraints = true
            self.dashboardView.navBar.view.layoutIfNeeded()
        })
    }
}

// MARK: Button Action
extension DashboardViewController: DashboardHeaderButtonDelegate, NavBarButtonDelegate {
    func didTapNotif() {
        router?.routeToNotification(segue: nil)
    }
    
    func didTapCheck() {
        // TODO: Get Location ID from tableview
        let request = DashboardModels.CheckLocation.Request(location: self.locationID)
        if self.locationID != "" {
            if isCheckOut {
                self.interactor?.checkOut(request: request)
                userDefault.set(false, forKey: "isCheckOut")
                isCheckOut = userDefault.bool(forKey: "isCheckOut")
                locationID = ""
            } else {
                self.interactor?.checkIn(request: request)
                userDefault.set(true, forKey: "isCheckOut")
                isCheckOut = userDefault.bool(forKey: "isCheckOut")
                locationID = ""
            }
            
        } else {
            let errMsg = "Please choose your location first"
            spinnerSetup(isSucces: false, message: errMsg)
        }
    }
}
